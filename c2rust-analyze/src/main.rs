#![feature(rustc_private)]
extern crate rustc_arena;
extern crate rustc_ast;
extern crate rustc_data_structures;
extern crate rustc_driver;
extern crate rustc_index;
extern crate rustc_interface;
extern crate rustc_middle;
extern crate rustc_mir_build;
extern crate rustc_session;
extern crate rustc_span;
extern crate rustc_target;

use std::collections::HashMap;
use std::env;
use std::hash::Hash;
use std::mem;
use polonius_engine::{self, Atom, FactTypes};
use rustc_ast::ast::{Item, ItemKind, Visibility, VisibilityKind};
use rustc_ast::node_id::NodeId;
use rustc_ast::ptr::P;
use rustc_driver::Compilation;
use rustc_interface::Queries;
use rustc_interface::interface::Compiler;
use rustc_middle::mir::{
    Body, BasicBlock, BasicBlockData, START_BLOCK, Terminator, TerminatorKind, SourceInfo, Local,
    LocalDecl, LocalKind, Mutability, Rvalue, AggregateKind, Place, Operand, Statement,
    StatementKind, BorrowKind, Constant, ConstantKind,
};
use rustc_middle::mir::interpret::{Allocation, ConstValue};
use rustc_middle::mir::pretty;
use rustc_middle::ty::{TyCtxt, Ty, TyKind, RegionKind, WithOptConstParam, List};
use rustc_middle::ty::query::{Providers, ExternProviders};
use rustc_session::Session;
use rustc_span::DUMMY_SP;
use rustc_span::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX};
use rustc_span::symbol::Ident;
use rustc_target::abi::Align;
use crate::atoms::{AllFacts, AtomMaps, SubPoint, Path, Loan};
use crate::labeled_ty::{LabeledTy, LabeledTyCtxt};

mod atoms;
mod def_use;
mod dump;
mod labeled_ty;
mod type_check;


pub type Label = Option<atoms::Origin>;
pub type LTy<'tcx> = LabeledTy<'tcx, Label>;
pub type LTyCtxt<'tcx> = LabeledTyCtxt<'tcx, Label>;


fn inspect_mir<'tcx>(
    tcx: TyCtxt<'tcx>,
    def: WithOptConstParam<LocalDefId>,
    mir: &Body<'tcx>,
) {
    let mut facts = AllFacts::default();
    let mut maps = AtomMaps::default();

    // Start the origin counter at 3.  This has no effect on the semantics, but makes for easier
    // diffs between our facts and the facts generated by rustc.
    for _ in 0..3 {
        let _ = maps.origin();
    }

    let name = tcx.item_name(def.to_global().did);
    eprintln!("\nprocessing function {:?}", name);
    //pretty::write_mir_fn(tcx, mir, &mut |_, _| Ok(()), &mut std::io::stdout()).unwrap();

    // Populate `cfg_edge`
    for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {
        eprintln!("{:?}:", bb);

        for idx in 0 .. bb_data.statements.len() {
            eprintln!("  {}: {:?}", idx, bb_data.statements[idx]);
            let start = maps.point(bb, idx, SubPoint::Start);
            let mid = maps.point(bb, idx, SubPoint::Mid);
            let next_start = maps.point(bb, idx + 1, SubPoint::Start);
            facts.cfg_edge.push((start, mid));
            facts.cfg_edge.push((mid, next_start));
        }

        let term_idx = bb_data.statements.len();
        eprintln!("  {}: {:?}", term_idx, bb_data.terminator());
        let term_start = maps.point(bb, term_idx, SubPoint::Start);
        let term_mid = maps.point(bb, term_idx, SubPoint::Mid);
        facts.cfg_edge.push((term_start, term_mid));
        for &succ in bb_data.terminator().successors() {
            let succ_start = maps.point(succ, 0, SubPoint::Start);
            facts.cfg_edge.push((term_mid, succ_start));
        }
    }

    // From rustc_borrowck::nll::populate_polonius_move_facts: "Non-arguments start out
    // deinitialised; we simulate this with an initial move"
    let entry_point = maps.point(START_BLOCK, 0, SubPoint::Start);
    for local in mir.local_decls.indices() {
        if mir.local_kind(local) != LocalKind::Arg {
            let path = maps.path(&mut facts, Place { local, projection: List::empty() });
            facts.path_moved_at_base.push((path, entry_point));
        }
    }

    // Populate `use_of_var_derefs_origin`, and generate `LTy`s for all locals.
    let ltcx = LabeledTyCtxt::new(tcx);
    let mut local_ltys = Vec::with_capacity(mir.local_decls.len());
    for (local, decl) in mir.local_decls.iter_enumerated() {
        let lty = assign_origins(ltcx, &mut facts, &mut maps, decl.ty);
        let var = maps.variable(local);
        lty.for_each_label(&mut |label| {
            if let Some(origin) = label {
                facts.use_of_var_derefs_origin.push((var, origin));
            }
        });
        local_ltys.push(lty);
    }

    let mut loans = HashMap::<Local, Vec<(Path, Loan, BorrowKind)>>::new();
    // Populate `loan_issued_at` and `loans`.
    type_check::visit(ltcx, &mut facts, &mut maps, &mut loans, &local_ltys, mir);
    /*
    // Populate `loan_issued_at` and `loans`.
    // TODO: also populate `subset_base` here
    for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {
        for (idx, stmt) in bb_data.statements.iter().enumerate() {
            let (lhs, rhs) = match stmt.kind {
                StatementKind::Assign(ref x) => (&x.0, &x.1),
                _ => continue,
            };
            let (borrow_kind, place) = match *rhs {
                Rvalue::Ref(_, bk, p) => (bk, p),
                _ => continue,
            };
            // TODO: need to do something with this origin (so it shows up in subset_base)
            let origin = maps.origin();
            let path = maps.path(&mut facts, place);
            let loan = maps.loan();
            loans.entry(place.local).or_default().push((path, loan, borrow_kind));
            let point = maps.point(bb, idx, SubPoint::Mid);
            facts.loan_issued_at.push((origin, loan, point));
        }
    }
    */

    // Populate `loan_invalidated_at`
    def_use::visit_loan_invalidated_at(tcx, &mut facts, &mut maps, &loans, mir);

    // Populate `var_defined/used/dropped_at` and `path_assigned/accessed_at_base`.
    def_use::visit(&mut facts, &mut maps, mir);


    dump::dump_facts_to_dir(&facts, &maps, format!("inspect/{}", name)).unwrap();

    let output = polonius_engine::Output::compute(
        &facts,
        polonius_engine::Algorithm::Naive,
        true,
    );
    dump::dump_output_to_dir(&output, &maps, format!("inspect/{}", name)).unwrap();
}

fn assign_origins<'tcx>(
    ltcx: LTyCtxt<'tcx>,
    facts: &mut AllFacts,
    maps: &mut AtomMaps<'tcx>,
    ty: Ty<'tcx>,
) -> LTy<'tcx> {
    ltcx.label(ty, &mut |ty| match ty.kind() {
        TyKind::Ref(_, _, _) => {
            Some(maps.origin())
        },
        _ => None,
    })
}


struct AnalysisCallbacks;

impl rustc_driver::Callbacks for AnalysisCallbacks {
    fn config(&mut self, config: &mut rustc_interface::Config) {
        config.override_queries = Some(override_queries);
    }
}

fn override_queries(
    sess: &Session,
    providers: &mut Providers,
    extern_providers: &mut ExternProviders,
) {
    providers.mir_built = |tcx, def: WithOptConstParam<LocalDefId>| {
        let mut providers = Providers::default();
        rustc_mir_build::provide(&mut providers);
        let steal_mir = (providers.mir_built)(tcx, def);

        inspect_mir(tcx, def, &steal_mir.borrow());

        steal_mir
    };
}

fn main() -> rustc_interface::interface::Result<()> {
    let mut args = env::args().collect::<Vec<_>>();
    rustc_driver::RunCompiler::new(&args, &mut AnalysisCallbacks).run()
}
